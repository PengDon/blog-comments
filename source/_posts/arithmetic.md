---
title: 算法学习笔记1
categories: 
- Arithmetic
tags: 
# mathjax: true # 支持数学公式
---

## 为什么学习算法？
算法的影响力是宽广和深远的。影响的领域不完全列表如下:
1. 网络。包括搜索，包路由，分布式共享文件。
1. 生物。包括基因工程，蛋白质折叠。
1. 计算机。电路草图，文件系统，编译器。
1. 计算机图形图像。电影，电子游戏，虚拟现实。
1. 安全。手机，电子商务，投票计算机。
1. 多媒体。mp3，jpg，divx，hdtv，人脸识别。
1. 社会网络。推荐系统，新闻feeding，广告学。
1. 物理学。n体模拟，粒子碰撞模拟。

## 什么是算法？
算法的定义：解决特定问题的求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
程序 = 数据结构 + 算法
数据结构：把现实世界中的问题信息化，将信息存入计算机。(要处理的信息)
算法：处理这些信息，以解决实际问题。(处理信息的步骤)


## 算法的特性
1. 输入。丢给算法处理的数据
1. 输出。算法处理的结果
1. 有穷性。有穷时间内能执行完(1.算法是有穷的 2.程序可以是无穷的)
1. 确定性。相同输入只会产生相同输出
1. 可行性。可用已有的基本操作实现算法

## 算法的要求
1. 正确性。能正确解决问题
1. 可读性。对算法的描述要让其他人也看得懂
1. 健壮性。算法能处理一些异常情况
1. 时间效率高和存储量低。(1.算法执行省时，省内存 2.时间复杂度低，空间复杂度低)

## 算法效率度量方法
1. 事后统计方法（不科学、不准确）
1. 事前分析估算方法
在分析程序的运行时间时，最重要的是把程序看成独立于程序设计语言的算法或一系列步骤。

## 算法的渐近增长
函数的渐近增长（概念）：给定两个函数 f(n) 和 g(n)，如果存在一个整数N，使得对于所有的 n>N, f(n) 总是比 g(n) 大，那么我们说 f(n) 的增长渐近快于 g(n) 。
（我的理解）就是给两个函数，n表示他们的规模，但n大于某一个值的时候，一个函数的值总是比另一个函数的大，那么我们可以理解这个函数渐近增长较快。

## 算法的时间复杂度（重点、难点）
1. 算法的时间复杂度定义：在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模n的函数，进而分析 T(n) 随n的变化情况并确定 T(n) 的数量级。算法的时间复杂度（算法的时间量度）记作 T(n) = O（f(n)）。表示随着问题规模n的增长，算法执行的时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。其中 f(n) 是问题规模n的某个函数。

2. 大O阶方法
>1. 用常数1取代运行时间中的所有加法常数。
>1. 在修改后的运行次数函数中，只保留最高阶项。
>1. 如果最高阶项存在且不为1，则去除与这个项相乘的常数，得到的结果就是大O阶，即时间复杂度。

3. 常见的时间复杂度所消耗时间的大小
> O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n) 

## 时间复杂度
1. 时间复杂度小结
时间复杂度是用来估计算法运行时间的一个式子(单位)。
一般来说，时间复杂度高的算法比复杂度低的算法慢。 
常见的时间复杂度（按效率排序） 
	O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n2logn) < O(n3) 
复杂问题的时间复杂度 
	O(n!) O(2n) O(nn) …

1. 简单快速判断算法的时间复杂度(适用大多数简单场景)
确定问题规模n 
循环减半过程→logn 
k层关于n的循环→nk 
复杂情况：根据算法执⾏行行过程判断

## 空间复杂度
1. 空间复杂度：用来评估算法内存占用大小的式子 (空间换时间)
- 空间复杂度的表示方式与时间复杂度完全一样 
- 算法使用了有限变量：O(1) 
- 算法使用了长度为n的一维列表：O(n) 
- 算法使用了m行n列的二维列表：O(mn) 
 



